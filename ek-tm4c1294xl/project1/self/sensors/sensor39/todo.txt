hdlc_monitor in/out журнал, счетчики

выяснить когда bNR++

читать К профилей

8.4.3.3 Receive ready (RR) command and response
The Receive ready, RR, frame shall be used by a data station to:
a) indicate that it is ready to receive an I frame(s); and
b) acknowledge previously received I frames numbered up to N(R) - 1 inclusive



Сдвиг времени – время изменяется на заданную величину от -900 до 900 секунд

unsigned char const OBIS_Time[]       = "0008-00.00.01.00.00.FF"; //Локальные дата/время

typedef enum
{
 GET_NORM_ACK    = 0x51 ,
 GET_NORM_NOACK  = 0x11 ,
 GET_BLOCK_ACK   = 0x52 ,
 GET_BLOCK_NOACK = 0x12 ,
 GET_LIST_ACK    = 0x53 ,
 GET_LIST_NOACK  = 0x13 ,

 SET_NORM_ACK    = 0x61 ,
 SET_NORM_NOACK  = 0x21 ,
 SET_BLOCK_ACK   = 0x62 ,
 SET_BLOCK_NOACK = 0x22 ,
 SET_LIST_ACK    = 0x63 ,
 SET_LIST_NOACK  = 0x23 ,

 ACT_NORM_ACK    = 0x71 ,
 ACT_NORM_NOACK  = 0x31 ,
 ACT_BLOCK_ACK   = 0x72 ,
 ACT_BLOCK_NOACK = 0x32 ,
 ACT_LIST_ACK    = 0x73 ,
 ACT_LIST_NOACK  = 0x33
} DLMS_ComTypeAck;

//Коррекция даты и времени
void DLMS_CORR_Time(void)
{
 DLMS_GET_SET_ACT(ACT_NORM_ACK, &OBIS_Time, 6);

 mbOut485[wSizeOut485-1] = 0x01;

 mbOut485[wSizeOut485++] = 0x10;

 if(dwSec < (-900)) dwSec = -900;
 else if(dwSec > 900) dwSec = 900;
 mbOut485[wSizeOut485++] = *((unsigned char*)(&dwSec)+1);
 mbOut485[wSizeOut485++] = *((unsigned char*)(&dwSec)+0);

 ConvertToHDLC(I_Control(),0);
}



//Формирует заголовок одной из основных команд DLMS (GET, SET, Action)
//ВХОД:
// DLMS_ComTypeAck - указывается Тэг сервиса, Тип сервиса, Флаг подтверждения
// pbOBIS - № класса + OBIS код
// bAttrMetod - номер атрибута или метода
//ВЫХОД:
// mbOut485[0..wSizeOut485-1] - сформированный заголовок DLMS команды
// wSizeOut485 - размер заголовка
void DLMS_GET_SET_ACT(DLMS_ComTypeAck enCTA, uchar *pbOBIS, uchar bAttrMetod)
{
 wSizeOut485 = 0;
 if((enCTA & 0x30) == 0x10) mbOut485[wSizeOut485++] = 0xC0;//GET
 else if((enCTA & 0x30) == 0x20) mbOut485[wSizeOut485++] = 0xC1;//SET
 else mbOut485[wSizeOut485++] = 0xC3;//Action
 mbOut485[wSizeOut485++] = enCTA & 0x0F;
 mbOut485[wSizeOut485++] = 0x81 | (enCTA & 0x40);

 if( (enCTA == GET_BLOCK_ACK) || (enCTA == GET_BLOCK_NOACK) )
 {
  mbOut485[wSizeOut485++] = 0;
  mbOut485[wSizeOut485++] = 0;
  mbOut485[wSizeOut485++] = 0;
  mbOut485[wSizeOut485++] = DLMS.bNumBlock;
 }
 else
 {
  DLMS_OBIStoBuff(&mbOut485[wSizeOut485], pbOBIS);
  wSizeOut485 += 8;
  mbOut485[wSizeOut485++] = bAttrMetod;
  mbOut485[wSizeOut485++] = 0x00;
 }
}//DLMS_GET_SET_ACT