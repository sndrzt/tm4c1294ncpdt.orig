//*****************************************************************************
// telnet.c - Telnet session support routines.
// Copyright (c) 2008-2013 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
// Texas Instruments (TI) is supplying this software for use solely and
// exclusively on TI's microcontroller products. The software is owned by
// TI and/or its suppliers, and is protected under applicable copyright
// laws. You may not combine this software with "viral" open-source
// software in order to form a larger program.
// 
// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
// DAMAGES, FOR ANY REASON WHATSOEVER.
// 
// This is part of revision 10636 of the RDK-S2E Firmware Package.
//*****************************************************************************

#include <stdint.h>
#include <stdbool.h>
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_sysctl.h"
#include "inc/hw_types.h"
#include "driverlib/debug.h"
#include "driverlib/flash.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/sysctl.h"
#include "driverlib/systick.h"
#include "driverlib/uart.h"
#include "utils/lwiplib.h"
#include "utils/ustdlib.h"
#include "lwip/sys.h"
#include "config.h"
#include "serial.h"
#include "telnet.h"
#ifdef DEBUG_UART
#include "utils/uartstdio.h"
#endif

//*****************************************************************************
//! \addtogroup telnet_api
//! @{
//*****************************************************************************

//*****************************************************************************
//! The bit in the flag that is set when the remote client has sent a WILL
//! request for SUPPRESS_GA and the server has accepted it.
//*****************************************************************************
#define OPT_FLAG_WILL_SUPPRESS_GA \
                                0

//*****************************************************************************
//! The bit in the flag that is set when the remote client has sent a DO
//! request for SUPPRESS_GA and the server has accepted it.
//*****************************************************************************
#define OPT_FLAG_DO_SUPPRESS_GA 1

//*****************************************************************************
//! The bit in the flag that is set when the remote client has sent a WILL
//! request for COM_PORT and the server has accepted it.
//*****************************************************************************
#if CONFIG_RFC2217_ENABLED
#define OPT_FLAG_WILL_RFC2217   2
#endif

//*****************************************************************************
//! The bit in the flag that is set when the remote client has sent a DO
//! request for COM_PORT and the server has accepted it.
//*****************************************************************************
#if CONFIG_RFC2217_ENABLED
#define OPT_FLAG_DO_RFC2217     3
#endif

//*****************************************************************************
//! The bit in the flag that is set when a connection is operating as a telnet
//! server.  If clear, this implies that this connection is a telnet client.
//*****************************************************************************
#define OPT_FLAG_SERVER         4

//*****************************************************************************
//! The possible states of the TCP session.
//*****************************************************************************
typedef enum
{
    //! The TCP session is idle.  No connection has been attempted, nor has it
    //! been configured to listen on any port.
    STATE_TCP_IDLE,

    //! The TCP session is listening (server mode).
    STATE_TCP_LISTEN,

    //! The TCP session is connecting (client mode).
    STATE_TCP_CONNECTING,

    //! The TCP session is connected.
    STATE_TCP_CONNECTED,
}
tTCPState;

//*****************************************************************************
//! The possible states of the telnet option parser.
//*****************************************************************************
typedef enum
{
    //! The telnet option parser is in its normal mode.  Characters are passed
    //! as is until an IAC byte is received.
    STATE_NORMAL,

    //! The previous character received by the telnet option parser was an IAC
    //! byte.
    STATE_IAC,

    //! The previous character sequence received by the telnet option parser
    //! was IAC WILL.
    STATE_WILL,

    //! The previous character sequence received by the telnet option parser
    //! was IAC WONT.
    STATE_WONT,

    //! The previous character sequence received by the telnet option parser
    //! was IAC DO.
    STATE_DO,

    //! The previous character sequence received by the telnet option parser
    //! was IAC DONT.
    STATE_DONT,

    //! The previous character sequence received by the telnet option parser
    //! was IAC SB.
    STATE_SB,

    //! The previous character sequence received by the telnet option parser
    //! was IAC SB n, where n is an unsupported option.
    STATE_SB_IGNORE,

    //! The previous character sequence received by the telnet option parser
    //! was IAC SB n, where n is an unsupported option.
    STATE_SB_IGNORE_IAC,

    //! The previous character sequence received by the telnet option parser
    //! was IAC SB COM-PORT-OPTION (in other words, RFC 2217).
#if defined(CONFIG_RFC2217_ENABLED) || defined(DOXYGEN)
    STATE_SB_RFC2217,
#endif
}
tTelnetState;

//*****************************************************************************
//! The possible states of the telnet COM-PORT option parser.
//*****************************************************************************
#if defined(CONFIG_RFC2217_ENABLED) || defined(DOXYGEN)
typedef enum
{
    //! The telnet COM-PORT option parser is ready to process the first
    //! byte of data, which is the sub-option to be processed.
    STATE_2217_GET_COMMAND,

    //! The telnet COM-PORT option parser is processing data bytes for the
    //! specified command/sub-option.
    STATE_2217_GET_DATA,

    //! The telnet COM-PORT option parser has received an IAC in the data
    //! stream.
    STATE_2217_GET_DATA_IAC,

}
tRFC2217State;
#endif

//*****************************************************************************
//! This structure is used holding the state of a given telnet session.
//*****************************************************************************
typedef struct
{
    //! This value holds the pointer to the TCP PCB associated with this
    //! connected telnet session.
    struct tcp_pcb *pConnectPCB;

    //! This value holds the pointer to the TCP PCB associated with this
    //! listening telnet session.
    struct tcp_pcb *pListenPCB;

    //! The current state of the TCP session.
    tTCPState eTCPState;

    //! The current state of the telnet option parser.
    tTelnetState eTelnetState;

    //! The listen port for the telnet server or the local port for the telnet
    //! client.
    uint16_t usTelnetLocalPort;

    //! The remote port that the telnet client connects to.
    uint16_t usTelnetRemotePort;

    //! The remote address that the telnet client connects to.
    uint32_t ulTelnetRemoteIP;

    //! Flags for various options associated with the telnet session.
    uint8_t ucFlags;

    //! A counter for the TCP connection timeout.
    uint32_t ulConnectionTimeout;

    //! The max time for TCP connection timeout counter.
    uint32_t ulMaxTimeout;

    //! This value holds the UART Port Number for this telnet session.
    uint32_t ulSerialPort;

    //! This value holds an array of pbufs.
    struct pbuf *pBufQ[PBUF_POOL_SIZE];

    //! This value holds the read index for the pbuf queue.
    int iBufQRead;

    //! This value holds the write index for the pbuf queue.
    int iBufQWrite;

    //! This value holds the head of the pbuf that is currently being
    //! processed (that has been popped from the queue).
    struct pbuf *pBufHead;

    //! This value holds the actual pbuf that is being processed within the
    //! pbuf chain pointed to by the pbuf head.
    struct pbuf *pBufCurrent;

    //! This value holds the offset into the payload section of the current
    //! pbuf.
    uint32_t ulBufIndex;

    //! The amount of time passed since rx byte count has changed.
    uint32_t ulLastTCPSendTime;

#if CONFIG_RFC2217_ENABLED
    //! The current state of the telnet option parser.
    tRFC2217State eRFC2217State;

    //! The COM-PORT Command being processed.
    uint8_t ucRFC2217Command;

    //! The COM-PORT value received (associed with the COM-PORT Command).
    uint32_t ulRFC2217Value;

    //! The index into the COM-PORT value received (for multi-byte values).
    uint8_t ucRFC2217Index;

    //! The maximum number of bytes expected (0 means ignore data).
    uint8_t ucRFC2217IndexMax;

    //! The response buffer for RFC2217 commands.
    uint8_t pucRFC2217Response[16];

    //! The RFC 2217 flow control value.
    uint8_t ucRFC2217FlowControl;

    //! The modem state mask.
    uint8_t ucRFC2217ModemMask;

    //! The line state mask.
    uint8_t ucRFC2217LineMask;

    //! The reported modem state.
    uint8_t ucModemState;

    //! The last reported modem state.
    uint8_t ucLastModemState;
#endif

    //! The indication that link layer has been lost.
    bool bLinkLost;

    //! Debug and diagnostic counters.
    uint8_t ucErrorCount;
    uint8_t ucReconnectCount;
    uint8_t ucConnectCount;

    //! The last error reported by lwIP while attempting to make a connection.
    err_t eLastErr;
}
tTelnetSessionData;

//*****************************************************************************
//! The initialization sequence sent to a remote telnet client when it first
//! connects to the telnet server.
//*****************************************************************************
static const uint8_t g_pucTelnetInit[] =
{
    TELNET_IAC, TELNET_DO, TELNET_OPT_SUPPRESS_GA,
#if CONFIG_RFC2217_ENABLED
    TELNET_IAC, TELNET_DO, TELNET_OPT_RFC2217,
#endif
};

//*****************************************************************************
//! The telnet session data array, for use in the telnet handler function.
//*****************************************************************************
static tTelnetSessionData g_sTelnetSession[MAX_S2E_PORTS];

//*****************************************************************************
// External Reference to millisecond timer.
//*****************************************************************************
extern uint32_t g_ulSystemTimeMS;

//*****************************************************************************
// Forward References.
//*****************************************************************************
static err_t TelnetConnected(void *arg, struct tcp_pcb *pcb, err_t err);

//*****************************************************************************
//! Format a block of HTML containing connection diagnostic information.
//!
//! \param pcBuffer is a pointer to a buffer into which the diagnostic text
//! will be written.
//! \param iLen is the length of the buffer pointed to by \e pcBuffer.
//! \param ucPort is the port number whose diagnostics are to be written.
//! Valid values are 0 or 1.
//!
//! This function formats a block of HTML text containing diagnostic
//! information on a given port's telnet connection status into the supplied
//! buffer.
//!
//! \return None.
//*****************************************************************************
#if ((defined ENABLE_WEB_DIAGNOSTICS) || (defined DOXYGEN))
void TelnetWriteDiagInfo(char *pcBuffer, int iLen, uint8_t ucPort)
{
    char *pcState;

    // Determine the current port state as a string.
    switch(g_sTelnetSession[ucPort].eTCPState)
    {
        case STATE_TCP_IDLE:
            pcState = "IDLE";
            break;

        case STATE_TCP_LISTEN:
            pcState = "LISTEN";
            break;

        case STATE_TCP_CONNECTING:
            pcState = "CONNECTING";
            break;

        case STATE_TCP_CONNECTED:
            pcState = "CONNECTED";
            break;

        default:
            pcState = "ILLEGAL!";
            break;
    }

    usnprintf(pcBuffer, iLen,
              "<html><body><h1>Port %d Diagnostics</h1>\r\n"
              "State: %s<br>\r\n"
              "Last Send: %d<br>\r\n"
              "Link Lost: %s<br>\r\n"
              "</body></html>\r\n",
              (int)ucPort,
              pcState,
              g_sTelnetSession[ucPort].ulLastTCPSendTime,
              g_sTelnetSession[ucPort].bLinkLost ? "YES" : "NO");
}
#endif

//*****************************************************************************
//! Free up any queued pbufs associated with at telnet session.
//!
//! \param pState is the pointer ot the telnet session state data.
//!
//! This will free up any pbufs on the queue, and any currently active pbufs.
//!
//! \return None.
//*****************************************************************************
static void
TelnetFreePbufs(tTelnetSessionData *pState)
{
    SYS_ARCH_DECL_PROTECT(lev);

    // This should be done in a protected/critical section.
    SYS_ARCH_PROTECT(lev);

    // Pop a pbuf off of the rx queue, if one is available, and we are
    // not already processing a pbuf.
    if(pState->pBufHead != NULL)
    {
        pbuf_free(pState->pBufHead);
        pState->pBufHead = NULL;
        pState->pBufCurrent = NULL;
        pState->ulBufIndex = 0;
    }

    while(pState->iBufQRead != pState->iBufQWrite)
    {
        pbuf_free(pState->pBufQ[pState->iBufQRead]);
        pState->iBufQRead = ((pState->iBufQRead + 1) % PBUF_POOL_SIZE);
    }

    // Restore previous level of protection.
    SYS_ARCH_UNPROTECT(lev);
}



//*****************************************************************************
//! Gets the current local port for a connection's telnet session.
//!
//! \param ulSerialPort is the serial port associated with this telnet session.
//!
//! This function returns the local port in use by the telnet session
//! associated with the given serial port.  If operating as a telnet server,
//! this port is the port that is listening for an incoming connection.  If
//! operating as a telnet client, this is the local port used to connect to
//! the remote server.
//!
//! \return None.
//*****************************************************************************
uint16_t
TelnetGetLocalPort(uint32_t ulSerialPort)
{
    // Check the arguments.
    ASSERT(ulSerialPort < MAX_S2E_PORTS);

    return(g_sTelnetSession[ulSerialPort].usTelnetLocalPort);
}

//*****************************************************************************
//! Gets the current remote port for a connection's telnet session.
//!
//! \param ulSerialPort is the serial port associated with this telnet session.
//!
//! This function returns the remote port in use by the telnet session
//! associated with the given serial port.  If operating as a telnet server,
//! this function will return 0.  If operating as a telnet client, this is the
//! server port that the connection is using.
//!
//! \return None.
//*****************************************************************************
uint16_t
TelnetGetRemotePort(uint32_t ulSerialPort)
{
    // Check the arguments.
    ASSERT(ulSerialPort < MAX_S2E_PORTS);

    return(g_sTelnetSession[ulSerialPort].usTelnetRemotePort);
}

//*****************************************************************************
//! Initializes the telnet session(s) for the Serial to Ethernet Module.
//!
//! This function initializes the telnet session data parameter block.
//!
//! \return None.
//*****************************************************************************
void
TelnetInit(void)
{
    int iPort;

    // Initialize the session data for each supported port.
    for(iPort = 0; iPort < MAX_S2E_PORTS; iPort++)
    {
        g_sTelnetSession[iPort].pConnectPCB = NULL;
        g_sTelnetSession[iPort].pListenPCB = NULL;
        g_sTelnetSession[iPort].eTCPState = STATE_TCP_IDLE;
        g_sTelnetSession[iPort].eTelnetState = STATE_NORMAL;
        g_sTelnetSession[iPort].ucFlags = 0;
        g_sTelnetSession[iPort].ulConnectionTimeout = 0;
        g_sTelnetSession[iPort].ulMaxTimeout = 0;
        g_sTelnetSession[iPort].ulSerialPort = MAX_S2E_PORTS;
        g_sTelnetSession[iPort].usTelnetRemotePort = 0;
        g_sTelnetSession[iPort].usTelnetLocalPort = 0;
        g_sTelnetSession[iPort].ulTelnetRemoteIP = 0;
        g_sTelnetSession[iPort].iBufQRead = 0;
        g_sTelnetSession[iPort].iBufQWrite = 0;
        g_sTelnetSession[iPort].pBufHead = NULL;
        g_sTelnetSession[iPort].pBufCurrent = NULL;
        g_sTelnetSession[iPort].ulBufIndex = 0;
        g_sTelnetSession[iPort].ulLastTCPSendTime = 0;
#if CONFIG_RFC2217_ENABLED
        g_sTelnetSession[iPort].eRFC2217State = STATE_2217_GET_DATA;
        g_sTelnetSession[iPort].ucRFC2217Command = 0;
        g_sTelnetSession[iPort].ulRFC2217Value = 0;
        g_sTelnetSession[iPort].ucRFC2217Index = 0;
        g_sTelnetSession[iPort].ucRFC2217IndexMax = 0;
        g_sTelnetSession[iPort].ucRFC2217FlowControl = 0;
        g_sTelnetSession[iPort].ucRFC2217ModemMask = 0;
        g_sTelnetSession[iPort].ucRFC2217LineMask = 0;
        g_sTelnetSession[iPort].ucLastModemState = 0;
        g_sTelnetSession[iPort].ucModemState = 0;
#endif
        g_sTelnetSession[iPort].bLinkLost = false;
        g_sTelnetSession[iPort].ucConnectCount = 0;
        g_sTelnetSession[iPort].ucReconnectCount = 0;
        g_sTelnetSession[iPort].ucErrorCount = 0;
        g_sTelnetSession[iPort].eLastErr = ERR_OK;
    }
}


//*****************************************************************************
//! Handles RFC2217 modem state notification.
//!
//! \param ulPort is the serial port for which the modem state changed.
//! \param ucModemState is the new modem state.
//!
//! This function should be called by the serial port code when the modem state
//! changes.  If RFC2217 is enabled, a notification message will be sent.
//!
//! \return None.
//*****************************************************************************
#if defined(CONFIG_RFC2217_ENABLED) || defined(DOXYGEN)
void
TelnetNotifyModemState(uint32_t ulPort, uint8_t ucModemState)
{
    tTelnetSessionData *pState;

    // Check the arguments.
    ASSERT(ulPort < MAX_S2E_PORTS);
    pState = &g_sTelnetSession[ulPort];

    // If Telnet protocol is disabled, simply return.
    if((g_sParameters.sPort[ulPort].ucFlags & PORT_FLAG_PROTOCOL) ==
            PORT_PROTOCOL_RAW)
    {
        return;
    }

    // Save the value.
    pState->ucModemState = ucModemState;
}
#endif

//*****************************************************************************
//! Handles link status notification.
//!
//! \param bLinkStatusUp is the boolean indicate of link layer status.
//!
//! This function should be called when the link layer status has changed.
//!
//! \return None.
//*****************************************************************************
void
TelnetNotifyLinkStatus(bool bLinkStatusUp)
{
    int iPort;

    // We don't care if the link is up, only if it goes down.
    if(bLinkStatusUp)
    {
        return;
    }

    // For every port, indicate that the link has been lost.
    for(iPort = 0; iPort < MAX_S2E_PORTS; iPort++)
    {
        g_sTelnetSession[iPort].bLinkLost = true;
    }
}

//*****************************************************************************
// Close the Doxygen group.
//! @}
//*****************************************************************************
